### javascript设计模式-适配器,装饰器和工厂

    要求
    前提知识
    基础的javascript编程知识
    用户级别
    所有

你已经来到javascript设计模式系列中的第二部分,自从接触第一部分已经有一段时间了,所以,你也可能想要在单例,复合,外观设计模式上提升自己,第三部分讨论了另外3种设计模式:代理,观察者,和命令

这一次,您将了解关于适配器,装饰器和工厂模式

### 适配器
这个适配器模式允许你将接口转换成(或适应)你的需要,这个可以通过创建另一个具有所需接口的对象来实现,并连接到你想要改变的接口对象

适配器图案的结构如下所示
![](http://i.imgur.com/N9rWaBI.png)

### 为什么你需要适配器？
通常情况下,你正在处理一个应用程序时,并且你决定需要更换一个应用程序,例如,用于保存日志或者某种性质的库,当你引进新的库来替换它时,它不可能具有完全相同的界面,从这里你有两个选择
1. 浏览所有的代码,并改变引用旧库里的所有内容
2. 创建一个新的适配器,使新的库可以使用,并与旧的库具有相同的界面

显然,在一些情况下,你的应用将是足够的轻小,或者对旧的库有足够的参考,觉得它更合适了,就可以回到代码中并更改它以匹配新的库,而不是使代码复杂化,抽象,但是,在大多数情况下,只需要创建适配器就可以实现省时

### 适配器的示例

为什么你不采取上述假设的日志方案,并将其用与我们的示例代码中?最初在你的代码中,你可以使用大多数浏览器内置的控制台来制作日志,但是有一些问题,它并不是内置到所有的浏览器(特别是旧版本浏览器)中，你看不到发生的日志,当其他用户使用你的应用程序时,你无法抓取看到自己测试时遇到的任何问题,所以,你决定要一个日志记录器,而不是使用Ajax将这些日志发送到服务器来处理,以下是你的新Ajax logger库的API,可能如下所示

    AjaxLogger.sendLog(arguments);
    AjaxLogger.sendInfo(arguments);
    AjaxLogger.sendDebug(arguments);
    etc...

显然,这个库的作者并没有意识到你会尝试用这个来代替控制台,所以他或者她觉得在每个方法的名字开始添加发送都是有必要的,现在你问,为什么我编辑这个库,改变这个方法的名称?在这里有好几个很好的理由不这样做,如果你需要更新该库,你的库将会被覆盖,所以你需要返回并在此更改,另外,你如果您从库内传送的网络中下载该库,则无法编辑他们,所以让我们来构建一个新的库适应新的库并与控制台具有相同的界面
    

    var AjaxLoggerAdapter = {
    log: function() {
        AjaxLogger.sendLog(arguments);
    },
    info: function() {
        AjaxLogger.sendInfo(arguments);
    },
    debug: function() {
        AjaxLogger.sendDebug(arguments);
    },...
    };



### 你怎么使用它?
我敢打赌,任何使用过控制台的人直接通过它的引用来调用它,所以,你如何获得每个调用console.xxx来引用新的适配器而不是控制台?如果你使用的是抽象(像工厂)检索控制台,那么你可以在该抽象层中进行更改,但是已经说明了,每个人都直接引用到控制台,那么,javascript是一种动态的语言,它允许在运行时更改事物,所以为什么不用新的Ajax日志适配器来覆盖控制台?
    
    window.console = AjaxLoggerAdapter;

那很简单,不是吗？小心,如果你在其它人使用的代码中执行此操作,则控制台不再像用户期望的那样运行,另外,不要因为这个例子的简单而被愚弄,在许多的情况下,你将无法轻松的映射到彼此的方法(比如发送日志记录),你可能不得不实际执行一些你自己的逻辑与将来的用户界面转换与新库保持兼容

### 装饰器
装饰器模式是与许多其他模式非常不同的,装饰器模式解决了在类上添加或更改功能,不为每个功能组合创建子类的问题,例如,你有一个默认功能类的汽车类,汽车有几个可以添加到车上的可选功能(例如,电动锁,电动车窗和空调),如果你想尝试着用子类化处理这个问题,你将共有8个类来覆盖所有的组合

* 汽车
* 电动锁
* 电动车窗
* 汽车空调
* 电动汽车锁和电动汽车窗
* 电动汽车锁和空调
* 电动汽车窗和空调
* 电动汽车窗和电动锁和空调

这个可以快速的通过添加另外一个选项,这又可以增加8个子类,很快就会失控,这个可以使用装饰器模式解决,所以每次添加一个新的选项时,你只创建一个类,而不是将类的数量加倍
### 装饰器的结构
这个装饰器通过使用与基础对象具有相同接口的装饰器对象包装基础对象(car)来工作,装饰器有几个可以处理方法的选项:

1. 它可以完全覆盖它所包含的对象的方法
2. 如果装饰器不影响方法的行为,它可以直接传递到包装对象
3. 这个装饰器可以在将调用传递到包装对象之前或之后添加行为

装饰器并没有限制只包装基础对象,他们也可以包装其他装饰器,因为他们都实现了相同的界面,一般结构上看起来像如下图所示
![](http://i.imgur.com/XXmpwhq.png)
### 一个装饰器的例子
让我们看看上面的汽车插图(illustration),并把它编写成代码,首先构建基础车类

 




